/*
 * NT35510 lcd driver
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */
#include <common.h>

#include <asm/arch/cpu.h>
#include <asm/arch/common_ud_defs.h>
#include <asm/arch/pwm.h>
#include <asm/arch/gpio.h>
#include <asm/io.h>

#include <nt35510.h>

#define LCD_RESET		GPIO_N(3, 22)
#define LCD_BACKLIGHT	GPIO_N(1, 30)

#define LCD_CMD_READ	(0x80)
#define LCD_CMD_DCX		(0x40)
#define LCD_CMD_HL		(0x20)

#define mdelay(n)		udelay((n)*1000)

typedef enum {
	DATA  = 0,
	CMD,
	DELAY
} LCD_CMD_TYPE;

struct lcd_reg {
	u16 index;
	u8 val;

	LCD_CMD_TYPE type;
};

static struct spi_slave *lcd_spi;

#if 0
#define LCD_DBG(fmt, arg...) \
	printf("[OTM8009A] %s (line:%d) :" fmt "\n", __func__, __LINE__, ## arg)
#else
#define LCD_DBG(fmt, arg...) do {} while (0)
#endif

static struct lcd_reg init_seq[] = {
	{0xFF00, 0xAA, DATA},
	{0xFF01, 0x55, DATA},
	{0xFF02, 0x25, DATA},
	{0xFF03, 0x01, DATA},

	{0xF300, 0x00, DATA},
	{0xF301, 0x32, DATA},
	{0xF302, 0x00, DATA},
	{0xF303, 0x38, DATA},
	{0xF304, 0x31, DATA},
	{0xF305, 0x08, DATA},
	{0xF306, 0x11, DATA},
	{0xF307, 0x00, DATA},

	/* Select Command Page '0' */
	{0xF000, 0x55, DATA},
	{0xF001, 0xAA, DATA},
	{0xF002, 0x52, DATA},
	{0xF003, 0x08, DATA},
	{0xF004, 0x00, DATA},

	{0xB000, 0x08, DATA}, /* falling edge of pclk */
	{0xB001, 0x00, DATA},
	{0xB002, 0x0A, DATA},
	{0xB003, 0x10, DATA},
	{0xB004, 0x10, DATA},

	{0xB100, 0xCC, DATA}, /* Display Option Control */
	{0xB101, 0x02, DATA},

	{0xB300, 0x00, DATA}, // Display Clock in RGB Interface
	{0xB600, 0x03, DATA}, // Source Output Data Hold Time Control
	{0xB700, 0x70, DATA}, // EQ Control Function for Gate Signals
	{0xB701, 0x70, DATA},
	{0xB800, 0x00, DATA}, // EQ Control Function for Source Driver
	{0xB801, 0x06, DATA},
	{0xB802, 0x06, DATA},
	{0xB803, 0x06, DATA},

	{0xBC00, 0x00, DATA}, // EQ Control Function for Source Driver
	{0xBC01, 0x00, DATA},
	{0xBC02, 0x00, DATA},

	{0xBD00, 0x01, DATA}, // Display Timing Control
	{0xBD01, 0x84, DATA},
	{0xBD02, 0x06, DATA},
	{0xBD03, 0x50, DATA},
	{0xBD04, 0x00, DATA},

	{0xCC01, 0x03, DATA}, // Display Timing Control (Gateless)
	{0xCC02, 0x01, DATA},
	{0xCC03, 0x06, DATA},

	// Select Command Page '1'
	{0xF000, 0x55, DATA},
	{0xF001, 0xAA, DATA},
	{0xF002, 0x52, DATA},
	{0xF003, 0x08, DATA},
	{0xF004, 0x01, DATA},

	{0xB000, 0x05, DATA}, // Setting AVDD Voltage
	{0xB001, 0x05, DATA},
	{0xB002, 0x05, DATA},

	{0xB100, 0x05, DATA}, // Setting AVEE Voltage
	{0xB101, 0x05, DATA},
	{0xB102, 0x05, DATA},

	{0xB200, 0x03, DATA}, // VCL Setting for LVGL
	{0xB201, 0x03, DATA},
	{0xB202, 0x03, DATA},

	{0xB800, 0x24, DATA}, // Power Control for VCL
	{0xB801, 0x24, DATA},
	{0xB802, 0x24, DATA},

	{0xB300, 0x0A, DATA}, // Setting VGH Voltage
	{0xB301, 0x0A, DATA},
	{0xB302, 0x0A, DATA},

	{0xB900, 0x24, DATA}, // Setting VGH Voltage
	{0xB901, 0x24, DATA},
	{0xB902, 0x24, DATA},

	{0xBF00, 0x01, DATA}, // VGH Output Voltage

	{0xB500, 0x08, DATA}, // Setting VGL_REG Voltage
	{0xB501, 0x08, DATA},
	{0xB502, 0x08, DATA},

	{0xBA00, 0x14, DATA}, // Power Control for VGLX
	{0xBA01, 0x14, DATA},
	{0xBA02, 0x14, DATA},

	{0xB400, 0x2D, DATA}, // Setting VRGH Voltage
	{0xB401, 0x2D, DATA},
	{0xB402, 0x2D, DATA},

	{0xBC00, 0x00, DATA}, // Setting VGMP and VGSP Voltage
	{0xBC01, 0x68, DATA},
	{0xBC02, 0x00, DATA},

	{0xBD00, 0x00, DATA}, // Setting VGMN and VGSN Voltage
	{0xBD01, 0x7c, DATA},
	{0xBD02, 0x00, DATA},

	{0xBE00, 0x00, DATA}, // Setting VCOM Offset Voltage
	{0xBE01, 0x3a, DATA},

	// Select Comman d Page '1'
	{0xF000, 0x55, DATA},
	{0xF001, 0xAA, DATA},
	{0xF002, 0x52, DATA},
	{0xF003, 0x01, DATA},

	//Gradient Control for Gamma Voltage
	{0xD000, 0x0B, DATA},
	{0xD001, 0x14, DATA},
	{0xD002, 0x0C, DATA},

	//Positive Gamma  for RED
	{0xD100, 0x00, DATA},
	{0xD101, 0x37, DATA},
	{0xD102, 0x00, DATA},
	{0xD103, 0x61, DATA},
	{0xD104, 0x00, DATA},
	{0xD105, 0x92, DATA},
	{0xD106, 0x00, DATA},
	{0xD107, 0xb4, DATA},
	{0xD108, 0x00, DATA},
	{0xD109, 0xcf, DATA},
	{0xD10A, 0x00, DATA},
	{0xD10B, 0xf6, DATA},
	{0xD10C, 0x01, DATA},
	{0xD10D, 0x2f, DATA},
	{0xD10E, 0x01, DATA},
	{0xD10F, 0x7f, DATA},
	{0xD110, 0x01, DATA},
	{0xD111, 0x97, DATA},
	{0xD112, 0x01, DATA},
	{0xD113, 0xc0, DATA},
	{0xD114, 0x01, DATA},
	{0xD115, 0xe5, DATA},
	{0xD116, 0x02, DATA},
	{0xD117, 0x25, DATA},
	{0xD118, 0x02, DATA},
	{0xD119, 0x5E, DATA},
	{0xD11A, 0x02, DATA},
	{0xD11B, 0x60, DATA},
	{0xD11C, 0x02, DATA},
	{0xD11D, 0x87, DATA},
	{0xD11E, 0x02, DATA},
	{0xD11F, 0xbe, DATA},
	{0xD120, 0x02, DATA},
	{0xD121, 0xe2, DATA},
	{0xD122, 0x03, DATA},
	{0xD123, 0x0f, DATA},
	{0xD124, 0x03, DATA},
	{0xD125, 0x30, DATA},
	{0xD126, 0x03, DATA},
	{0xD127, 0x5c, DATA},
	{0xD128, 0x03, DATA},
	{0xD129, 0x77, DATA},
	{0xD12A, 0x03, DATA},
	{0xD12B, 0x94, DATA},
	{0xD12C, 0x03, DATA},
	{0xD12D, 0x9f, DATA},
	{0xD12E, 0x03, DATA},
	{0xD12F, 0xac, DATA},
	{0xD130, 0x03, DATA},
	{0xD131, 0xba, DATA},
	{0xD132, 0x03, DATA},
	{0xD133, 0xf1, DATA},

	//Posit, ive Gamma  for GREEN
	{0xD200, 0x00, DATA},
	{0xD201, 0x37, DATA},
	{0xD202, 0x00, DATA},
	{0xD203, 0x61, DATA},
	{0xD204, 0x00, DATA},
	{0xD205, 0x92, DATA},
	{0xD206, 0x00, DATA},
	{0xD207, 0xb4, DATA},
	{0xD208, 0x00, DATA},
	{0xD209, 0xcf, DATA},
	{0xD20A, 0x00, DATA},
	{0xD20B, 0xf6, DATA},
	{0xD20C, 0x01, DATA},
	{0xD20D, 0x2f, DATA},
	{0xD20E, 0x01, DATA},
	{0xD20F, 0x7f, DATA},
	{0xD210, 0x01, DATA},
	{0xD211, 0x97, DATA},
	{0xD212, 0x01, DATA},
	{0xD213, 0xc0, DATA},
	{0xD214, 0x01, DATA},
	{0xD215, 0xe5, DATA},
	{0xD216, 0x02, DATA},
	{0xD217, 0x25, DATA},
	{0xD218, 0x02, DATA},
	{0xD219, 0x5E, DATA},
	{0xD21A, 0x02, DATA},
	{0xD21B, 0x60, DATA},
	{0xD21C, 0x02, DATA},
	{0xD21D, 0x87, DATA},
	{0xD21E, 0x02, DATA},
	{0xD21F, 0xbe, DATA},
	{0xD220, 0x02, DATA},
	{0xD221, 0xe2, DATA},
	{0xD222, 0x03, DATA},
	{0xD223, 0x0f, DATA},
	{0xD224, 0x03, DATA},
	{0xD225, 0x30, DATA},
	{0xD226, 0x03, DATA},
	{0xD227, 0x5c, DATA},
	{0xD228, 0x03, DATA},
	{0xD229, 0x77, DATA},
	{0xD22A, 0x03, DATA},
	{0xD22B, 0x94, DATA},
	{0xD22C, 0x03, DATA},
	{0xD22D, 0x9f, DATA},
	{0xD22E, 0x03, DATA},
	{0xD22F, 0xac, DATA},
	{0xD230, 0x03, DATA},
	{0xD231, 0xba, DATA},
	{0xD232, 0x03, DATA},
	{0xD233, 0xf1, DATA},

	//Positive Gamma  for BLUE
	{0xD300, 0x00, DATA},
	{0xD301, 0x37, DATA},
	{0xD302, 0x00, DATA},
	{0xD303, 0x61, DATA},
	{0xD304, 0x00, DATA},
	{0xD305, 0x92, DATA},
	{0xD306, 0x00, DATA},
	{0xD307, 0xb4, DATA},
	{0xD308, 0x00, DATA},
	{0xD309, 0xcf, DATA},
	{0xD30A, 0x00, DATA},
	{0xD30B, 0xf6, DATA},
	{0xD30C, 0x01, DATA},
	{0xD30D, 0x2f, DATA},
	{0xD30E, 0x01, DATA},
	{0xD30F, 0x7f, DATA},
	{0xD310, 0x01, DATA},
	{0xD311, 0x97, DATA},
	{0xD312, 0x01, DATA},
	{0xD313, 0xc0, DATA},
	{0xD314, 0x01, DATA},
	{0xD315, 0xe5, DATA},
	{0xD316, 0x02, DATA},
	{0xD317, 0x25, DATA},
	{0xD318, 0x02, DATA},
	{0xD319, 0x5E, DATA},
	{0xD31A, 0x02, DATA},
	{0xD31B, 0x60, DATA},
	{0xD31C, 0x02, DATA},
	{0xD31D, 0x87, DATA},
	{0xD31E, 0x02, DATA},
	{0xD31F, 0xbe, DATA},
	{0xD320, 0x02, DATA},
	{0xD321, 0xe2, DATA},
	{0xD322, 0x03, DATA},
	{0xD323, 0x0f, DATA},
	{0xD324, 0x03, DATA},
	{0xD325, 0x30, DATA},
	{0xD326, 0x03, DATA},
	{0xD327, 0x5c, DATA},
	{0xD328, 0x03, DATA},
	{0xD329, 0x77, DATA},
	{0xD32A, 0x03, DATA},
	{0xD32B, 0x94, DATA},
	{0xD32C, 0x03, DATA},
	{0xD32D, 0x9f, DATA},
	{0xD32E, 0x03, DATA},
	{0xD32F, 0xac, DATA},
	{0xD330, 0x03, DATA},
	{0xD331, 0xba, DATA},
	{0xD332, 0x03, DATA},
	{0xD333, 0xf1, DATA},

	//Nega, tive Gamma  for RED
	{0xD400, 0x00, DATA},
	{0xD401, 0x37, DATA},
	{0xD402, 0x00, DATA},
	{0xD403, 0x50, DATA},
	{0xD404, 0x00, DATA},
	{0xD405, 0x89, DATA},
	{0xD406, 0x00, DATA},
	{0xD407, 0xa9, DATA},
	{0xD408, 0x00, DATA},
	{0xD409, 0xc0, DATA},
	{0xD40A, 0x00, DATA},
	{0xD40B, 0xf6, DATA},
	{0xD40C, 0x01, DATA},
	{0xD40D, 0x14, DATA},
	{0xD40E, 0x01, DATA},
	{0xD40F, 0x48, DATA},
	{0xD410, 0x01, DATA},
	{0xD411, 0x6b, DATA},
	{0xD412, 0x01, DATA},
	{0xD413, 0xa7, DATA},
	{0xD414, 0x01, DATA},
	{0xD415, 0xd3, DATA},
	{0xD416, 0x02, DATA},
	{0xD417, 0x17, DATA},
	{0xD418, 0x02, DATA},
	{0xD419, 0x4f, DATA},
	{0xD41A, 0x02, DATA},
	{0xD41B, 0x51, DATA},
	{0xD41C, 0x02, DATA},
	{0xD41D, 0x86, DATA},
	{0xD41E, 0x02, DATA},
	{0xD41F, 0xbd, DATA},
	{0xD420, 0x02, DATA},
	{0xD421, 0xe2, DATA},
	{0xD422, 0x03, DATA},
	{0xD423, 0x0f, DATA},
	{0xD424, 0x03, DATA},
	{0xD425, 0x30, DATA},
	{0xD426, 0x03, DATA},
	{0xD427, 0x5c, DATA},
	{0xD428, 0x03, DATA},
	{0xD429, 0x77, DATA},
	{0xD42A, 0x03, DATA},
	{0xD42B, 0x94, DATA},
	{0xD42C, 0x03, DATA},
	{0xD42D, 0x9f, DATA},
	{0xD42E, 0x03, DATA},
	{0xD42F, 0xac, DATA},
	{0xD430, 0x03, DATA},
	{0xD431, 0xba, DATA},
	{0xD432, 0x03, DATA},
	{0xD433, 0xf1, DATA},

	//Negative Gamma  for GERREN
	{0xD500, 0x00, DATA},
	{0xD501, 0x37, DATA},
	{0xD502, 0x00, DATA},
	{0xD503, 0x50, DATA},
	{0xD504, 0x00, DATA},
	{0xD505, 0x89, DATA},
	{0xD506, 0x00, DATA},
	{0xD507, 0xa9, DATA},
	{0xD508, 0x00, DATA},
	{0xD509, 0xc0, DATA},
	{0xD50A, 0x00, DATA},
	{0xD50B, 0xf6, DATA},
	{0xD50C, 0x01, DATA},
	{0xD50D, 0x14, DATA},
	{0xD50E, 0x01, DATA},
	{0xD50F, 0x48, DATA},
	{0xD510, 0x01, DATA},
	{0xD511, 0x6b, DATA},
	{0xD512, 0x01, DATA},
	{0xD513, 0xa7, DATA},
	{0xD514, 0x01, DATA},
	{0xD515, 0xd3, DATA},
	{0xD516, 0x02, DATA},
	{0xD517, 0x17, DATA},
	{0xD518, 0x02, DATA},
	{0xD519, 0x4f, DATA},
	{0xD51A, 0x02, DATA},
	{0xD51B, 0x51, DATA},
	{0xD51C, 0x02, DATA},
	{0xD51D, 0x86, DATA},
	{0xD51E, 0x02, DATA},
	{0xD51F, 0xbd, DATA},
	{0xD520, 0x02, DATA},
	{0xD521, 0xe2, DATA},
	{0xD522, 0x03, DATA},
	{0xD523, 0x0f, DATA},
	{0xD524, 0x03, DATA},
	{0xD525, 0x30, DATA},
	{0xD526, 0x03, DATA},
	{0xD527, 0x5c, DATA},
	{0xD528, 0x03, DATA},
	{0xD529, 0x77, DATA},
	{0xD52A, 0x03, DATA},
	{0xD52B, 0x94, DATA},
	{0xD52C, 0x03, DATA},
	{0xD52D, 0x9f, DATA},
	{0xD52E, 0x03, DATA},
	{0xD52F, 0xac, DATA},
	{0xD530, 0x03, DATA},
	{0xD531, 0xba, DATA},
	{0xD532, 0x03, DATA},
	{0xD533, 0xf1, DATA},

	//Negative Gamma  for BLUE
	{0xD600, 0x00, DATA},
	{0xD601, 0x37, DATA},
	{0xD602, 0x00, DATA},
	{0xD603, 0x50, DATA},
	{0xD604, 0x00, DATA},
	{0xD605, 0x89, DATA},
	{0xD606, 0x00, DATA},
	{0xD607, 0xa9, DATA},
	{0xD608, 0x00, DATA},
	{0xD609, 0xc0, DATA},
	{0xD60A, 0x00, DATA},
	{0xD60B, 0xf6, DATA},
	{0xD60C, 0x01, DATA},
	{0xD60D, 0x14, DATA},
	{0xD60E, 0x01, DATA},
	{0xD60F, 0x48, DATA},
	{0xD610, 0x01, DATA},
	{0xD611, 0x6b, DATA},
	{0xD612, 0x01, DATA},
	{0xD613, 0xa7, DATA},
	{0xD614, 0x01, DATA},
	{0xD615, 0xd3, DATA},
	{0xD616, 0x02, DATA},
	{0xD617, 0x17, DATA},
	{0xD618, 0x02, DATA},
	{0xD619, 0x4f, DATA},
	{0xD61A, 0x02, DATA},
	{0xD61B, 0x51, DATA},
	{0xD61C, 0x02, DATA},
	{0xD61D, 0x86, DATA},
	{0xD61E, 0x02, DATA},
	{0xD61F, 0xbd, DATA},
	{0xD620, 0x02, DATA},
	{0xD621, 0xe2, DATA},
	{0xD622, 0x03, DATA},
	{0xD623, 0x0f, DATA},
	{0xD624, 0x03, DATA},
	{0xD625, 0x30, DATA},
	{0xD626, 0x03, DATA},
	{0xD627, 0x5c, DATA},
	{0xD628, 0x03, DATA},
	{0xD629, 0x77, DATA},
	{0xD62A, 0x03, DATA},
	{0xD62B, 0x94, DATA},
	{0xD62C, 0x03, DATA},
	{0xD62D, 0x9f, DATA},
	{0xD62E, 0x03, DATA},
	{0xD62F, 0xac, DATA},
	{0xD630, 0x03, DATA},
	{0xD631, 0xba, DATA},
	{0xD632, 0x03, DATA},
	{0xD633, 0xf1, DATA},

	{0x2A00, 0x00, DATA},
	{0x2A01, 0x00, DATA},
	{0x2A02, 0x01, DATA},
	{0x2A03, 0xdf, DATA},

	{0x2B00, 0x00, DATA},
	{0x2B01, 0x00, DATA},
	{0x2B02, 0x03, DATA},
	{0x2B03, 0x1f, DATA},

	{0x3600, 0x40, DATA},
	{0x3A00, 0x77, DATA}, /* 24-bit RGB */
};

static int lcd_send_word(struct spi_slave *spi, u8 cmd, u8 data)
{
	int err = 0;
	u8 buffer = 0;
	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<D[8:0]>
	 */
	err = spi_xfer(spi, 8, &cmd, NULL, SPI_XFER_BEGIN);
	if (err)
		return err;

	buffer = (data & 0xff);
	return spi_xfer(spi, 8, &buffer, NULL, SPI_XFER_END);
}

static int lcd_read_word(struct spi_slave *spi, u8 *word)
{
	int err = 0;
	u8 buffer = 0;

	if (word == NULL)
		return 1;
	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<D[8:0]>
	 */
	buffer = (LCD_CMD_READ | LCD_CMD_DCX);
	err = spi_xfer(spi, 8, &buffer, NULL, SPI_XFER_BEGIN);
	if (err)
		return err;

	return spi_xfer(spi, 8, NULL, word, SPI_XFER_END);
}

static int lcd_read(struct spi_slave *spi, u16 idx, u8 *param)
{
	int ret = 0;
	u8 buffer = 0;

	if (param == NULL)
		return 1;

	spi_claim_bus(spi);

	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<IR[15:8]>
	 */
	ret = lcd_send_word(spi, LCD_CMD_HL, (idx >> 8)&0xff);
	if (ret) {
		LCD_DBG("Error with the spi transmit.\n");
		return ret;
	}

	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<IR[7:0]>
	 */
	ret = lcd_send_word(spi, 0x00, (idx & 0xff));
	if (ret) {
		LCD_DBG("Error with the spi transmit.\n");
		return ret;
	}

	/*
	 * The dummy read
	 * <R/W><DCX><H/L>XXXXX<IR[7:0]>
	 */
	ret = lcd_read_word(spi, &buffer);
	if (ret) {
		LCD_DBG("Error with the spi receive.\n");
		return ret;
	}

	/*
	 * The actual read
	 * <R/W><DCX><H/L>XXXXX<IR[7:0]>
	 */
	ret = lcd_read_word(spi, &buffer);
	if (ret) {
		LCD_DBG("Error with the spi receive.\n");
		return ret;
	}
	*param = buffer;

	spi_release_bus(spi);

	return 0;
}

static int lcd_write(struct spi_slave *spi, int cmd, u16 idx, u8 value)
{
	int ret = 0;

	spi_claim_bus(spi);

	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<IR[15:8]>
	 */
	ret = lcd_send_word(spi, LCD_CMD_HL, (idx >> 8)&0xff);
	if (ret) {
		LCD_DBG("Error with the spi transmit.\n");
		return ret;
	}

	/*
	 * The transmit word (x:don't care)
	 * <R/W><DCX><H/L>XXXXX<IR[7:0]>
	 */
	ret = lcd_send_word(spi, 0x00, (idx & 0xff));
	if (ret) {
		LCD_DBG("Error with the spi transmit.\n");
		return ret;
	}

	if (cmd == DATA) {
		/*
		 * The transmit word (x:don't care)
		 * <R/W><DCX><H/L>XXXXX<D[8:0]>
		 */
		ret = lcd_send_word(spi, LCD_CMD_DCX, value);
		if (ret) {
			LCD_DBG("Error with the spi transmit.\n");
			return ret;
		}
	}

	spi_release_bus(spi);

	return 0;
}

int lcd_init(struct lcd_config *config)
{
	struct lcd_reg *regs = (struct lcd_reg *)init_seq;

	int i, ret = 0;

	/* lcd reset */
	gpio_set_value(LCD_RESET, 0);
	udelay(50); /* wait for more than 10us */
	gpio_set_value(LCD_RESET, 1);
	/*
	 * wait for reset complete during sleep in
	 * min 5ms
	 */
	mdelay(10);

	lcd_spi = spi_setup_slave(config->bus, config->cs, 5000000, SPI_MODE_3);
	if (!lcd_spi)
		return 1;

	/* software reset */
	lcd_write(lcd_spi, CMD, 0x0100, 0);
	/* wait for loads factory default vaules */
	mdelay(10);

	regs = (struct lcd_reg *)init_seq;
	for (i = 0; i < ARRAY_SIZE(init_seq); i++, regs++) {
		if (regs->type == DELAY)
			mdelay(regs->val);
		else
			lcd_write(lcd_spi, regs->type, regs->index, regs->val);
	}

	return 0;
}

int lcd_enable(void)
{
	if (!lcd_spi) {
		puts ("Couldn't initialize spi!!\n");
		return 1;
	}

	/* sleep out */
	lcd_write(lcd_spi, CMD, 0x1100, 0);
	mdelay(120); /* delay 120ms or more */
	/* display on */
	lcd_write(lcd_spi, CMD, 0x2900, 0);
	/* wait 100ms */
	mdelay(100);
	/* memory access on from mpu to lcd */
	lcd_write(lcd_spi, CMD, 0x2C00, 0);
	mdelay(20);

	gpio_set_value(LCD_BACKLIGHT, 1); /* backlight on */

	return 0;
}

void lcd_spi_free(void)
{
	if (lcd_spi) {
		spi_free_slave(lcd_spi);
		lcd_spi = NULL;
	}
}